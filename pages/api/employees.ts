import { createServerSupabaseClient } from '@/lib/supabase-server';
import { NextApiRequest, NextApiResponse } from 'next';
import type { Employee } from '@/lib/supabase.types';
import { calculatePay, shouldCalculatePay } from '@/lib/pay-calculator';
import { allPositionsQualified } from '@/lib/certification-utils';
import { fetchEmployeePositionAverages } from '@/lib/fetch-position-averages';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return res.status(200).end();
  }

  try {
    const supabase = createServerSupabaseClient();

    if (req.method === 'GET') {
      // Fetch employees
      const { location_id } = req.query;
      
      if (!location_id) {
        return res.status(400).json({ error: 'location_id is required' });
      }

      const { data: employees, error } = await supabase
        .from('employees')
        .select('*')
        .eq('location_id', location_id)
        .eq('active', true)
        .order('full_name');

      if (error) {
        console.error('Error fetching employees:', error);
        return res.status(500).json({ error: 'Failed to fetch employees' });
      }

      // Add cache headers for better performance (cache for 60 seconds, stale-while-revalidate for 120 seconds)
      res.setHeader('Cache-Control', 'public, s-maxage=60, stale-while-revalidate=120');

      return res.status(200).json({ employees: employees || [] });
    }

    if (req.method === 'POST') {
      const { intent } = req.body;

      // Handle create employee
      if (intent === 'create') {
        const {
          first_name,
          last_name,
          full_name,
          role,
          availability,
          is_foh,
          is_boh,
          location_id,
          org_id,
        } = req.body;

        if (!first_name || !last_name || !role || !availability || !location_id || !org_id) {
          return res.status(400).json({ error: 'Missing required fields' });
        }

        if (!is_foh && !is_boh) {
          return res.status(400).json({ error: 'At least one of is_foh or is_boh must be true' });
        }

        const employeeData: Partial<Employee> = {
          first_name,
          last_name,
          full_name: full_name || `${first_name} ${last_name}`.trim(),
          role,
          availability,
          is_foh: is_foh || false,
          is_boh: is_boh || false,
          location_id,
          org_id,
          active: true,
          certified_status: 'Not Certified',
        };

        // Calculate pay if this is a CFA Buda/West Buda location
        if (shouldCalculatePay(location_id)) {
          // Create a temporary employee object for pay calculation
          const tempEmployee: Employee = {
            id: '', // Will be generated by database
            first_name: employeeData.first_name!,
            last_name: employeeData.last_name!,
            full_name: employeeData.full_name!,
            role: employeeData.role!,
            availability: employeeData.availability!,
            is_foh: employeeData.is_foh || false,
            is_boh: employeeData.is_boh || false,
            location_id: employeeData.location_id!,
            org_id: employeeData.org_id!,
            active: true,
            certified_status: 'Not Certified',
          };
          const calculatedPay = calculatePay(tempEmployee);
          if (calculatedPay !== null) {
            employeeData.calculated_pay = calculatedPay;
          }
        }

        const { data, error } = await supabase
          .from('employees')
          .insert(employeeData)
          .select()
          .single();

        if (error) {
          console.error('Error creating employee:', error);
          console.error('Employee data attempted:', employeeData);
          return res.status(500).json({ 
            error: 'Failed to create employee',
            details: error.message,
            code: error.code,
          });
        }

        return res.status(201).json({ employee: data });
      }

      // Handle update employee
      if (intent === 'update') {
        const { id, role, is_certified, certified_status, is_foh, is_boh, availability } = req.body;

        if (!id) {
          return res.status(400).json({ error: 'Invalid request parameters' });
        }

      // First, get current employee data to check location and calculate pay
      const { data: currentEmployee, error: fetchError } = await supabase
        .from('employees')
        .select('*')
        .eq('id', id)
        .single();

      if (fetchError || !currentEmployee) {
        console.error('Error fetching employee:', fetchError);
        return res.status(404).json({ error: 'Employee not found' });
      }

      const updateData: Partial<Employee> = {};
      const previousStatus = currentEmployee.certified_status || 'Not Certified';
      
      // Track if any pay-affecting fields changed
      let payFieldsChanged = false;

      if (role !== undefined) {
        updateData.role = role;
        payFieldsChanged = true;
      }
      // Handle both old is_certified (boolean) and new certified_status (enum) for backwards compatibility
      if (certified_status !== undefined) {
        updateData.certified_status = certified_status;
        payFieldsChanged = true;
      } else if (is_certified !== undefined) {
        // Legacy: convert boolean to certification status
        updateData.certified_status = (is_certified === 'true' || is_certified === true) ? 'Certified' : 'Not Certified';
        payFieldsChanged = true;
      }
      if (is_foh !== undefined) {
        updateData.is_foh = is_foh === 'true' || is_foh === true;
        payFieldsChanged = true;
      }
      if (is_boh !== undefined) {
        updateData.is_boh = is_boh === 'true' || is_boh === true;
        payFieldsChanged = true;
      }
      if (availability !== undefined) {
        updateData.availability = availability;
        payFieldsChanged = true;
      }

      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ error: 'No valid fields to update' });
      }

      updateData.updated_at = new Date().toISOString();

      // Calculate pay if this is a CFA Buda/West Buda location and pay-affecting fields changed
      if (payFieldsChanged && shouldCalculatePay(currentEmployee.location_id)) {
        const updatedEmployee = { ...currentEmployee, ...updateData };
        const calculatedPay = calculatePay(updatedEmployee);
        if (calculatedPay !== null) {
          updateData.calculated_pay = calculatedPay;
        }
      }

      const { data, error } = await supabase
        .from('employees')
        .update(updateData)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('Error updating employee:', error);
        return res.status(500).json({ error: 'Failed to update employee' });
      }

      if (
        previousStatus === 'Not Certified' &&
        data?.certified_status === 'Pending'
      ) {
        await ensureEvaluationForPending(supabase, data as Employee);
      }

      return res.status(200).json({ employee: data });
      }

      return res.status(400).json({ error: 'Invalid intent. Use "create" or "update"' });
    }

    return res.status(405).json({ error: 'Method not allowed' });
  } catch (error) {
    console.error('API error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

function addMonths(date: Date, months: number): Date {
  const clone = new Date(date);
  clone.setMonth(clone.getMonth() + months);
  return clone;
}

function formatMonthLabel(date: Date): string {
  return date.toLocaleString('en-US', { month: 'long' });
}

async function ensureEvaluationForPending(supabase: ReturnType<typeof createServerSupabaseClient>, employee: Employee) {
  try {
    const { data: existing } = await supabase
      .from('evaluations')
      .select('id')
      .eq('employee_id', employee.id)
      .in('status', ['Planned', 'Scheduled'])
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    const averages = await fetchEmployeePositionAverages([employee], supabase);
    const positions = averages[0]?.positions || {};
    const ratingStatus = Object.keys(positions).length > 0 && allPositionsQualified(positions);

    if (existing) {
      await supabase
        .from('evaluations')
        .update({
          rating_status: ratingStatus,
          updated_at: new Date().toISOString(),
        })
        .eq('id', existing.id);
      return;
    }

    const evaluationMonth = formatMonthLabel(addMonths(new Date(), 1));

    const { error: insertError } = await supabase.from('evaluations').insert({
      employee_id: employee.id,
      employee_name: employee.full_name,
      location_id: employee.location_id,
      org_id: employee.org_id,
      leader_id: null,
      leader_name: null,
      evaluation_date: null,
      month: evaluationMonth,
      role: employee.role,
      status: 'Planned',
      rating_status: ratingStatus,
      state_before: 'Pending',
      state_after: null,
      notes: null,
    });

    if (insertError) {
      console.error('[Employees API] Failed to create evaluation record:', insertError);
    }
  } catch (error) {
    console.error('[Employees API] Unexpected error while creating evaluation:', error);
  }
}
